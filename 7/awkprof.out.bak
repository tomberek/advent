	# Loaded extensions (-l and/or @load)

	@load "ordchr"
	@load "rwarray"
	@load "/nix/store/bn25s9fbvdyxfgl8c22xnr35jfzyf1n6-gawkextlib-unstable/lib/json.so"

# Remove warnings
true = 0 {
	print $0
}

true + /; exec -a "$0" gawk --lint -f "$0" -- "$@"; / {
	#!/bin/sh
	# Trick to allow this file to be self contained as a polyglot shell and awk script
}

match($0, /^Step (\w) must be finished before step (\w) can begin.$/, arr) {
	data[arr[1]] = data[arr[1]] arr[2]
	datab[arr[2]] = datab[arr[2]] arr[1]
	print arr[1] ":-:" data[arr[1]]
}

END {
	FS = ""
	$0 = alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	result_1 = go(top)
	print ""
}

END {
	$0 = alphabet
	delete completed
	while (length(result) < 26) {
		for (i = 1; i <= 15; i++) {
			if (worker[i]["job"] != "") {
				worker[i]["time"]++
				if (worker[i]["time"] == ord(worker[i]["job"]) - 3) {
					completed[worker[i]["job"]] = 1
					result = result worker[i]["job"]
					worker[i]["job"] = ""
					worker[i]["time"] = 0
				}
			}
		}
		for (i = 1; i <= 15; i++) {
			if (worker[i]["job"] == "") {
				possible = ready(datab, data, completed)
				if (possible != "!") {
					worker[i]["job"] = possible
					worker[i]["time"] = 1
					in_progress[worker[i]["job"]] = 1
					$0 = filter_queue(in_progress)
					$0 = filter_queue(completed)
				}
			}
		}
		for (i = 1; i < 15; i++) {
			printf "%1s-%2d ", worker[i]["job"], worker[i]["time"]
		}
		printf "   :::\t%d\t%s\n", t, result
		t += 1
	}
}

END {
	print "step 1: " result_1
	print "step 2: " result
}


function abs(x)
{
	if (x < 0) {
		return -x
	}
	return x
}

function clamp(x, x_min, x_max)
{
	if (x < x_min) {
		return x_min
	}
	if (x > x_max) {
		return x_max
	}
	return x
}

function copy_array(dest, source, i, count)
{
	delete dest
	for (i in source) {
		if (typeof(source[i]) == "array") {
			count += copy_array(dest[i], source[i])
		} else {
			dest[i] = source[i]
			count++
		}
	}
	return count
}

function filter_queue(completed, present, i, out)
{
	for (i = 1; i <= NF; i++) {
		if (completed[$i] == 0 && present[$i] == 0) {
			present[$i] = 1
			out = out $i
		}
	}
	return out
}

function go(top, result)
{
	$0 = filter_queue(completed)
	print $0
	print "read"
	result = ""
	while ($0 != "") {
		printf "%s", top
		result = result top
		completed[top] = 1
		$0 = filter_queue(completed)
		top = ready(datab, data, completed)
	}
	return result
}

function join(array, start, end, sep, result, i)
{
	if (sep == "") {
		sep = " "
	} else if (sep == SUBSEP) {
		sep = ""	# magic value
	}
	result = array[start]
	for (i = start + 1; i <= end; i++) {
		result = result sep array[i]
	}
	return result
}

# BEGIN rule(s)
function printa(source, level, count)
{
	printf "%s%s\n", level, "{"
	level = level "\t"
	for (i in source) {
		if (typeof(source[i]) == "array") {
			count += printa(source[i], level)
		} else {
			dest[i] = source[i]
			printf "%s%s :\t%s\n", level, i, source[i]
			count++
		}
	}
	level = substr(level, 1, length(level) - 1)
	printf "%s%s\n", level, "}"
	return count
}

function readfile(file, tmp, save_rs)
{
	save_rs = RS
	RS = "^$"
	getline tmp < file
	close(file)
	RS = save_rs
	return tmp
}

function ready(datab, data, completed, i, j, temp, all, preqs)
{
	for (i = 1; i <= NF; i++) {
		split(datab[$i], preqs, "")
		for (j in preqs) {
			if (completed[preqs[j]] != 1) {
				all = 1
			}
		}
		if (all != 1) {
			return $i
		}
		all = 0
	}
	return "!"
}

function rewind(i)
{
	# shift remaining arguments up
	for (i = ARGC; i > ARGIND; i--) {
		ARGV[i] = ARGV[i - 1]
	}
	# make sure gawk knows to keep going
	ARGC++
	# make current file next to get done
	ARGV[ARGIND + 1] = FILENAME
	# do it
	nextfile
}

function round(x, ival, aval, fraction)
{
	ival = int(x)	# integer part, int() truncates
	# see if fractional part
	if (ival == x) {
		return ival	# no fraction
		# ensure no decimals
	}
	if (x < 0) {
		aval = -x	# absolute value
		ival = int(aval)
		fraction = aval - ival
		if (fraction >= .5) {
			return (int(x) - 1)	# -2.5 --> -3
		} else {
			return int(x)	# -2.3 --> -2
		}
	} else {
		fraction = x - ival
		if (fraction >= .5) {
			return (ival + 1)
		} else {
			return ival
		}
	}
}
